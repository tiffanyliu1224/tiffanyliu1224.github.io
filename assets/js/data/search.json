[ { "title": "影像處理小白（六）：Run-Length Encoding 壓縮圖片", "url": "/posts/run_length_encoding/", "categories": "Python, 影像處理", "tags": "Python, OpenCV, image processing, RLE, compression", "date": "2023-06-06 22:24:00 +0800", "snippet": "這是學校選修課的功課紀錄，同步發布於 該課程 Blogger 功課要求附件中為三張利用將晶片高度以色彩視覺化後的圖片。 請設計一個基於Run-Length 的壓縮法方，對圖檔作無失真壓縮後儲存成新檔案。部落格上應敘述你的壓縮方法，提供壓縮檔之格式，並計算三張圖的平均壓縮率(compression ratio)。成果得到檔案的壓縮率與平均壓縮率開發環境 OS Editor Language OpenCV Windows 10 Visual Studio Code Python 3.9.16 OpenCV 4.5.4 實作 本次程式碼使用的 libraries 如下：import cv2, osimport matplotlib.pyplot as pltimport numpy as np1/ 利用迴圈讀入三張圖片建立一個儲存三張圖片路徑的 list ，使用迴圈搭配 cv2.imread(filename) 讀入圖片並送至 compress(original_img, compress_file) 進行壓縮，取得壓縮率並儲存在 compress_ratio[i] 中。 def main(): img_path = [&quot;img1.bmp&quot;, &quot;img2.bmp&quot;, &quot;img3.bmp&quot;] compress_path = [&quot;img1.dat&quot;, &quot;img2.dat&quot;, &quot;img3.dat&quot;] # 跑過三張圖片 compress_ratio = [0, 0, 0] print(&quot;| Image Name | Original Size | Compress Size | Compression Ratio |&quot;) print(&quot;| ---------- | -------------- | -------------- | ----------------- |&quot;) for i in range(0, len(img_path)): original_img = img_path[i] compress_file = compress_path[i] compress_ratio[i] = compress(original_img, compress_file)2/ 壓縮圖片2.1/ 計算圖片大小使用 os.path.getsize(filename) 取得圖片大小，並使用 with open(compress_file, &quot;w&quot;) as file 寫入壓縮檔案中，做為解壓縮時建立 array 的參考。img = cv2.imread(img_path) with open(compress_file, &quot;w&quot;) as file: # 記下圖片大小 img_size = [img.shape[0], img.shape[1]] file.write(str(img_size[0]) + &quot;, &quot; + str(img_size[1]) + &quot;\\n&quot;)2.2/ 將二維的圖片轉為一維三個 channel 的值不會一樣，所以三個通道必須分開儲存。 一維的圖片比較好操控，而且能夠增加壓縮的效率，所以使用 flatten() 將二維的矩陣轉換至一維。# 三個 channel 分開跑for channel in range(0, 3): img_channel = img[:, :, channel] img_flat = img_channel.flatten()2.3/ Run-Length Encoding遍歷矩陣中所有的 pixel ，如果當前 pixel 和上一個 pixel 相等，數量就 + 1，不相等就將當前 pixel 的值和數量寫入 .dat 檔中。並且利用 \\n 來分隔每個 channel 的資料。last_pixel = 0pixel_count = 0# 遍歷每個 pixelfor pixel in img_flat: if pixel == last_pixel: pixel_count += 1 else: file.write(str(last_pixel) + &quot;, &quot; + str(pixel_count) + &quot;, &quot;) pixel_count = 1 last_pixel = pixel# 存入最後一筆資料file.write(str(last_pixel) + &quot;, &quot; + str(pixel_count) + &quot;\\n&quot;)2.4/ 計算壓縮率首先，利用 os.path.getsize(filename) 取得檔案大小。 壓縮率的計算為 原檔案大小 / 壓縮檔案大小，相除之後使用 formatted string 顯示在表格中。（也可以不用表格啦但我覺得這樣方便看）original_size = os.path.getsize(img_path)compress_size = os.path.getsize(compress_file)compress_ratio = original_size / compress_sizeprint(f&quot;| {compress_file:10} | {str(original_size):7} bytes | {str(compress_size):8} bytes | {str(round(compress_ratio, 5)):17} |&quot;)return compress_ratio3/ 解壓縮圖片在 main() 中呼叫 decompress(compress_file) 來將剛才產生的 dat 檔轉換回圖片並使用 plt 顯示。decompress_img = decompress(compress_file)plt.subplot(2, 2, i + 1)plt.imshow(decompress_img)plt.title(img_path[i])plt.axis(&quot;off&quot;)3.1/ 創建畫布使用 img_size = file.readline().rstrip(&#39;\\n&#39;).split(&quot;, &quot;) 取得圖片的大小之後，建立一個擁有三個元素的二維 list ，每一個元素是儲存 B, G, R 單個通道的資料，每一個元素的大小為 img_size[0] * img_size[1] 。 同時，使用 file.read().split(&quot;\\n&quot;) 讀取剩下的資料，每一個通道的值是使用 \\n 做分割，其中每一個 pixel 的值用 , 分割。with open(compress_file, &quot;r&quot;) as file: # 讀取圖片大小 img_size = file.readline().rstrip(&#39;\\n&#39;).split(&quot;, &quot;) # 讀取剩下的資料 row_data = file.read().split(&quot;\\n&quot;) data = [row_data[i].split(&quot;, &quot;) for i in range(0, len(row_data))] # 創建畫布 image_bgr = [np.zeros(int(img_size[0]) * int(img_size[1]), dtype=np.uint8), np.zeros(int(img_size[0]) * int(img_size[1]), dtype=np.uint8), np.zeros(int(img_size[0]) * int(img_size[1]), dtype=np.uint8)]3.2/ 將 pixel 填上 arrayimage_bgr 中，依序填入 B, G, R 通道的資料。 for channel in range (0, 3): pixel_count = 0 for index in range(0, len(data[channel]), 2): pixel_length = pixel_count + int(data[channel][index + 1]) for i in range(pixel_count, pixel_length): image_bgr[channel][i] = np.uint8(data[channel][index]) pixel_count = pixel_length3.3/ Merge 三個通道成一張圖片將填好值的一維 array 使用 reshape() 轉換成二維矩陣，並使用 cv2.merge() 合併三個通道，使其變成 BGR 的彩色圖片。 由於要在 plt 做顯示，所以使用 cv2.cvtColor() 將 BGR 轉換成 RGB 。# 將三個通道合併image_b = image_bgr[0].reshape(int(img_size[0]), int(img_size[1]))image_g = image_bgr[1].reshape(int(img_size[0]), int(img_size[1]))image_r = image_bgr[2].reshape(int(img_size[0]), int(img_size[1]))result_img = cv2.merge([image_b, image_g, image_r])# 將 BGR 改成 RGBimage = cv2.cvtColor(result_img, cv2.COLOR_BGR2RGB)# return 解壓縮完的圖片return image4/ 計算平均壓縮率將三張圖片的壓縮率加總後平均並輸出，最後使用 plt.show() 顯示圖片。average_ratio = sum(compress_ratio) / len(compress_ratio)print(&quot;Average compression ratio: &quot; + str(average_ratio) + &quot;.&quot;) plt.show()總結Run-length encoding 可以用來壓縮相同顏色連續出現的圖片，不過如果圖片沒有大量相同的顏色相鄰，壓縮效果可能會不太好。參考資料 图像处理（一）：基于行程编码的图像压缩python实现 numpy.reshape 運行長度編碼 (RLE) 數據壓縮算法" }, { "title": "影像處理小白（五）：利用 HSV 色域找到膚色區域", "url": "/posts/skin_detection/", "categories": "Python, 影像處理", "tags": "Python, OpenCV, image processing, skin detection, HSV", "date": "2023-05-16 18:34:00 +0800", "snippet": "這是學校選修課的功課紀錄，同步發布於 該課程 Blogger 功課要求偵測輸入照片中的皮膚區域並將其標示出：成果程式完成後的執行結果，膚色區域以紅色標記開發環境 OS Editor Language OpenCV Windows 10 Visual Studio Code Python 3.9.16 OpenCV 4.5.4 實作 本次程式碼使用的 libraries 如下：import cv2import matplotlib.pyplot as pltimport numpy as np1/ 利用迴圈讀入三張圖片建立一個儲存三張圖片路徑的 list ，使用迴圈搭配 cv2.imread(filename) 讀入圖片並顯示。 顯示圖片中有一點要注意， plt 使用的彩色圖片是 RGB ，而 OpenCV 讀入的圖片是以 BGR 編碼，所以必須透過 cv2.cvtColor(original_img, cv2.COLOR_BGR2RGB) 來轉換要顯示的圖片，不然就會出現三名藍色皮膚的人。images = [&#39;img1.jpg&#39;, &#39;img2.jpg&#39;, &#39;img3.jpg&#39;]image_count = 0for image in images: print(&quot;Now processing: &quot;, image) # read image original_img = cv2.imread(image) # show original image plt.subplot(3, 3, image_count * 3 + 1) plt.imshow(cv2.cvtColor(original_img, cv2.COLOR_BGR2RGB)) plt.title(&quot;Original Image&quot;) plt.axis(&quot;off&quot;)2/ 轉換圖片色域並設定膚色範圍RGB 色域容易受到光線等因素影響，導致難以判斷顏色是否為膚色，使用 cv2.cvtColor(src, code) 轉換至 HSV 色域後就能把色相、飽和度、明度分開看。# convert to HSV color spacehsv_img = cv2.cvtColor(original_img, cv2.COLOR_BGR2HSV)# convert to YCrCb color spaceycbcr_img = cv2.cvtColor(original_img, cv2.COLOR_BGR2YCrCb)創建 array 來儲存膚色的範圍，這是我採用的範圍： H: 0 ~ 17 S: 50 ~ 170 V: 0 ~ 255 Y: 0 ~ 255 Cr: 135 ~ 180 Cb: 85 ~ 135調整過後我仍舊無法避免有些非皮膚（頭髮、陰影等）處還是會被判別為膚色 QQ # create skin upper and lower boundslower_skin = np.array([0, 50, 0], dtype=np.uint8)upper_skin = np.array([17, 170, 255], dtype=np.uint8)lower_skin_ycbcr = np.array((0, 135, 85), dtype=np.uint8)upper_skin_ycbcr = np.array((255, 180, 135), dtype=np.uint8)3/ 提取膚色區域使用 cv2.inRange(src, lowerb, upperb) 提取膚色區域，獲得一張和原尺寸相同大小的二值化 mask ，膚色區域為白色，其他地方為黑色，就如結果圖中第二個 column 顯示的那樣。# find skin color in the imageskin_mask_hsv = cv2.inRange(hsv_img, lower_skin, upper_skin)skin_mask_ycbcr = cv2.inRange(ycbcr_img, lower_skin_ycbcr, upper_skin_ycbcr)skin_mask = cv2.bitwise_and(skin_mask_hsv, skin_mask_ycbcr)# show skin maskplt.subplot(3, 3, image_count * 3 + 2)plt.imshow(skin_mask, cmap=&quot;gray&quot;)plt.title(&quot;Skin Mask&quot;)plt.axis(&quot;off&quot;)4/ 將原圖膚色區域標示為紅色最後在 skin_mask 不為 0 的像素，更改原圖的顏色為紅色。# make skin region redskin_region = original_img.copy()skin_region[skin_mask != 0] = [0, 0, 255]# show skin regionplt.subplot(3, 3, image_count * 3 + 3)plt.imshow(cv2.cvtColor(skin_region, cv2.COLOR_BGR2RGB))plt.title(&quot;Skin Region&quot;)plt.axis(&quot;off&quot;)別忘記迴圈的最後要 += 1 和程式結束前要顯示圖片。 image_count += 1plt.show()總結將圖片轉換至 HSV 色域後，可以減少光線明暗造成的影響。參考資料 Human Skin Detection Using RGB, HSV and YCbCr Color Models OpenCV 探索之路（二十七）：皮膚檢測技術 CHEREF-Mehdi/SkinDetection" }, { "title": "影像處理小白（四）：利用頻域圖像消除週期性雜訊", "url": "/posts/notch_filter/", "categories": "Python, 影像處理", "tags": "Python, OpenCV, image processing, DFT, noise reduction, frequency domain, notch filter", "date": "2023-05-04 01:30:00 +0800", "snippet": "這是學校選修課的功課紀錄，同步發布於 該課程 Blogger 功課要求圖片似乎受到某種頻域雜訊干擾，撰寫一個程式嘗試復原此圖像。成果程式完成後的執行結果開發環境 OS Editor Language OpenCV Windows 10 Visual Studio Code Python 3.9.16 OpenCV 4.5.4 實作 本次程式碼使用的 libraries 如下：import cv2import matplotlib.pyplot as pltimport numpy as np1/ 使用 DFT 取得頻域圖像與頻譜圖這裡可以去看 影像處理小白（三）：使用 DFT 將影像轉換至頻域 ，步驟都一樣。2/ 用滑鼠點選 notch pointsnotch point 通常用來消除圖像上的特定頻率，這裡我們透過觀察，可以發現頻譜圖上有六個週期性出現的亮點，所以來進行手動選取。建立一個 function 將點擊處的值設為 0:def add_notch_point(event, x, y, flags, img): # if button is clicked, mark the point if event == cv2.EVENT_LBUTTONDOWN: print(&quot;added nothch point at: &quot;, x, y) # draw a circle cv2.circle(img, (x, y), 20, 0, -1)使用 cv2.setMouseCallback() 建立一個可供點擊的視窗：# mouse click to find notch pointsnotch_points_img = np.ones(magnitude.shape, dtype=np.uint8)cv2.namedWindow(&#39;Frequency Domain Image&#39;)cv2.setMouseCallback(&#39;Frequency Domain Image&#39;, add_notch_point, notch_points_img)cv2.imshow(&#39;Frequency Domain Image&#39;, magnitude)cv2.waitKey(0)在這裡就能知道當時有平移 DFT 圖像的好處了，可以很快的發現哪些亮點是週期性的重複出現。3/ 平移得到的 notch points 圖像剛才我們都是看著平移過的頻譜圖進行點擊，但原先的 DFT 結果並非這樣，所以我們要反向的把 notch points 圖像給平移回來。# swap notch points to match dft_Atmp = np.copy(notch_points_img[0:cy, 0:cx])notch_points_img[0:cy, 0:cx] = notch_points_img[cy:dft_A.shape[0], cx:dft_A.shape[1]]notch_points_img[cy:dft_A.shape[0], cx:dft_A.shape[1]] = tmptmp = np.copy(notch_points_img[0:cy, cx:dft_A.shape[1]])notch_points_img[0:cy, cx:dft_A.shape[1]] = notch_points_img[cy:dft_A.shape[0], 0:cx]notch_points_img[cy:dft_A.shape[0], 0:cx] = tmp4/ 套用 notch filter將原本的 DFT 圖像的兩個通道和平移過的 notch filter 相乘，消除滑鼠點過的黑點部分，週期性雜訊就會被去除掉。# apply notch filterplanes[0] = planes[0] * notch_points_imgplanes[1] = planes[1] * notch_points_imgdftB = cv2.merge(planes)5/ 利用反向 DFT 還原圖片最後使用 cv2.idft() 還原圖像，由於前面已經把刪除好雜訊的 dftB 做出來了，所以這邊只要還原就能得到去除雜訊後的圖像。# inverse dft_Bcv2.idft(dftB, dftB)cv2.split(dftB, planes)# get magnitudeinverse_img = cv2.magnitude(planes[0], planes[1])# normalize to 0~255cv2.normalize(inverse_img, inverse_img, 0, 255, cv2.NORM_MINMAX)# convert to 8 bit unsigned integerinverse_img = inverse_img.astype(np.uint8)總結將影像轉換至頻域後，透過觀察可以消除一些週期性出現的亮點，從而消除週期性雜訊。參考資料 Periodic Noise Removing Filter" }, { "title": "影像處理小白（三）：使用 DFT 將影像轉換至頻域", "url": "/posts/convert_image_to_frequency_domain/", "categories": "Python, 影像處理", "tags": "Python, OpenCV, image processing, DFT, frequency domain", "date": "2023-04-19 22:30:00 +0800", "snippet": "這是學校選修課的功課紀錄，同步發布於 該課程 Blogger 功課要求 撰寫傅利葉轉換程式 (Forward Fourier Transform and Inverse Fourier Transform) 將一張圖像轉換至頻域 將頻譜大小與相位角度各以灰階256 色圖像方式呈現出 呈現還原後圖像成果程式完成後的執行結果開發環境 OS Editor Language OpenCV Windows 10 Visual Studio Code Python 3.9.16 OpenCV 4.5.4 實作 本次程式碼話說 Copilot 真的好用，這次的作業有一半是他給了我建議我再去查函式定義。使用的 libraries 如下：import cv2import matplotlib.pyplot as pltimport numpy as np1/ 讀取圖片並顯示cv2.imread(file_name, cv2.IMREAD_GRAYSCALE) 會以灰階模式讀入一張圖。# Read imageoriginal_img = cv2.imread(&quot;.\\\\image3.png&quot;, cv2.IMREAD_GRAYSCALE)再使用 plt 創建一個 2*2 空間的畫布，並以灰階模式顯示，加上 title 和 axis off 讓他更美觀。plt.subplot(2, 2, 1)plt.imshow(original_img, cmap=&#39;gray&#39;)plt.title(&quot;Original Image&quot;)plt.axis(&quot;off&quot;)2/ 調整圖像大小DFT 在某些大小的畫布下可以計算得比較快，所以我們透過在圖片的右方與下方插入白色畫布，拓展他的尺寸。 getOptimalDFTSize() 可以幫我們取得 x 軸和 y 軸所要調整的最佳大小。使用 np.zeros() 創建一個 dft_M * dft_N 大小的白色畫布，在畫布左上角用 original_img 覆蓋。# get optimal size for dftdft_M = cv2.getOptimalDFTSize(original_img.shape[0])dft_N = cv2.getOptimalDFTSize(original_img.shape[1])# add zero paddingdft_A = np.zeros((dft_M, dft_N), dtype=np.float32)dft_A[:original_img.shape[0], :original_img.shape[1]] = original_img3/ 計算 DFT由於 DFT 結果是複數，包含實部和虛部，所以使用二維 array planes 協助我們儲存。 利用 cv2.dft() 算 DFT 後，再使用 cv2.split() 將實部虛部兩個通道分開。 cv2.magnitude(x, y) 的原理是實部相乘 + 虛部相乘，公式為 $ dst(I) = \\sqrt{x(I)^2 + y(I)^2}$ ，再來對它取 log。為什麼是這樣算？這就是傅立葉轉換的數學範疇了，在這裡就不多做自虐。 關於傅立葉小白，推薦 圖解傅立葉分析 ，看完這篇後我終於有點理解頻域在做什麼了。# make two channel for dft (real and imaginary)planes = [dft_A, np.zeros(dft_A.shape, np.float32)]dft_A = cv2.merge(planes)cv2.dft(dft_A, dft_A)cv2.split(dft_A, planes)#compute the magnitudemagnitude = cv2.magnitude(planes[0], planes[1])magnitude = np.log(magnitude + 1)4/ 平移頻譜圖頻譜圖有時候會需要平移一下，將重點放到圖片中心，好讓人類觀看，例如做完以上步驟後的圖如下：亮部集中在四個角落的頻譜圖但如果把四個角的亮部移到中心，我們會更好觀察，所以剛剛那張圖我們這樣切割：| 0 | 1 || 2 | 3 |若要將亮部移動到中心位置，就必須 0、3 互換， 1、2 互換。 這裡我選用了比較原始的方法， numpy 可以使用 ffshift 函式 方便許多。最後用正規化便於我們顯示灰階圖片。# shift to centercx = int(dft_A.shape[1] / 2)cy = int(dft_A.shape[0] / 2)q0 = magnitude[0:cy, 0:cx]q1 = magnitude[0:cy, cx:dft_A.shape[1]]q2 = magnitude[cy:dft_A.shape[0], 0:cx]q3 = magnitude[cy:dft_A.shape[0], cx:dft_A.shape[1]]# swap diagonal quadrantstmp = np.copy(q0)magnitude[0:cy, 0:cx] = q3magnitude[cy:dft_A.shape[0], cx:dft_A.shape[1]] = tmptmp = np.copy(q1)magnitude[0:cy, cx:dft_A.shape[1]] = q2magnitude[cy:dft_A.shape[0], 0:cx] = tmpcv2.normalize(magnitude, magnitude, 0, 1, cv2.NORM_MINMAX)然後使用 plt 顯示圖片。# show frequency domain image after shiftplt.subplot(2, 2, 2)plt.imshow(magnitude, cmap=&#39;gray&#39;)plt.title(&quot;Frequency Domain Image After Shift&quot;)plt.axis(&quot;off&quot;)顯示出來的結果：亮部集中於圖片中間的頻譜圖5/ 相位角度圖相位角度通常用來描述圖片的輪廓與細節，這裡直接使用 cv2.phase() 來提取相角，再用和上一步一樣的方法進行平移。# get phase imagephase = cv2.phase(planes[0], planes[1], angleInDegrees=True)# shift to centerq0 = phase[0:cy, 0:cx]q1 = phase[0:cy, cx:dft_A.shape[1]]q2 = phase[cy:dft_A.shape[0], 0:cx]q3 = phase[cy:dft_A.shape[0], cx:dft_A.shape[1]]# swap diagonal phasetmp = np.copy(q0)phase[0:cy, 0:cx] = q3phase[cy:dft_A.shape[0], cx:dft_A.shape[1]] = tmptmp = np.copy(q1)phase[0:cy, cx:dft_A.shape[1]] = q2phase[cy:dft_A.shape[0], 0:cx] = tmpcv2.normalize(phase, phase, 0, 1, cv2.NORM_MINMAX)# convert to 8 bit unsigned integerphase = phase * 255phase = phase.astype(np.uint8)# show phase imageplt.subplot(2, 2, 3)plt.imshow(phase, cmap=&#39;gray&#39;)plt.title(&quot;Phase Image&quot;)plt.axis(&quot;off&quot;)6/ 還原圖片最後使用 DFT 得出的 dft_A 來還原圖片，使用 cv2.idft() 做反向的傅立葉轉換， cv2.split() 與 cv2.magnitude() 取得轉換後的影像， normalize 後就能以 unsigned 8 bits 的方式輸出灰階影像。# get inverse dftcv2.idft(dft_A, dft_A)cv2.split(dft_A, planes)# get inverse imageinverse_img = cv2.magnitude(planes[0], planes[1])# normalize to 0~255cv2.normalize(inverse_img, inverse_img, 0, 255, cv2.NORM_MINMAX)# convert to 8 bit unsigned integerinverse_img = inverse_img.astype(np.uint8)# show inverse imageplt.subplot(2, 2, 4)plt.imshow(inverse_img, cmap=&#39;gray&#39;)plt.title(&quot;Inverse Image&quot;)plt.axis(&quot;off&quot;)plt.show()總結DFT 能將影像從時域轉至頻域，可以用來找出影像中週期性出現的雜訊。參考資料 【沒錢ps,我用OpenCV!】Day 14 - 進階修圖1，運用 OpenCV 顯示圖片直方圖、分離與合併RGB通道 show histogram, split, merge RGB channel Opencv 例程講解7 —- DFT圖像傅立葉變換 圖解傅立葉分析" }, { "title": "影像處理小白（二）：影像邊緣偵測", "url": "/posts/image-edge-detection/", "categories": "Python, 影像處理", "tags": "Python, OpenCV, image processing, edge detection, Sobel operators, Gaussian blur, noise reduction", "date": "2023-03-23 22:30:00 +0800", "snippet": "這是學校選修課的功課紀錄，同步發布於 該課程 Blogger 功課要求撰寫一個程式，以灰階模式讀取一張圖像 imread(path, IMREAD_GRAYSCALE) 利用 Sobel Operators 偵測並輸出邊緣成分圖 設計一個類似素描線條的自畫像圖案。成果開發環境 OS Editor Language OpenCV Windows 10 Visual Studio Code Python 3.9.16 OpenCV 4.5.4 實作 本次程式碼使用的 library 如下：import cv2import matplotlib.pyplot as pltimport numpy as np1/ 讀取灰階圖片colored_img 用以展示彩色的原圖，而 cv2.imread(file_name, cv2.IMREAD_GRAYSCALE) 會以灰階模式讀入一張圖。file_name = &quot;.\\\\fig.jpg&quot;colored_img = cv2.imread(file_name)gray_img = cv2.imread(file_name, cv2.IMREAD_GRAYSCALE)和上一個程式不同，這次的圖片輸出如下： 使用 result_img 儲存所有要顯示的圖片，一個個將他們貼到 plt 中，這裡帶入了 plt.axis(&quot;off&quot;) 隱藏 matplotlib 預設的 x 軸和 y 軸的刻度。result_img = [colored_img]fig = plt.figure()def show_img(): for i in range(0, len(result_img)): image_rgb = cv2.cvtColor(result_img[i], cv2.COLOR_BGR2RGB) fig.add_subplot(2, 2, i + 1) plt.imshow(image_rgb) plt.axis(&quot;off&quot;) plt.show()2/ 邊緣成分圖首先利用高斯模糊 (Gaussian blur) 去除雜訊（噪聲），使邊界更好檢測： # 高斯模糊協助過濾雜訊gray_img = cv2.GaussianBlur(gray_img,(3, 3), 0)result_img.append(gray_img)再利用索伯算子 (Sobel operaters) 提取 x 方向和 y 方向的邊界，之後將兩者的絕對值相加，獲得完整的邊緣成分圖。# 提取 x 方向和 y 方向的邊緣edge_x = cv2.Sobel(gray_img, cv2.CV_16S, 1, 0, 3)edge_Y = cv2.Sobel(gray_img, cv2.CV_16S, 0, 1, 3)# 轉換為 unit8 （提取絕對值）abs_x = cv2.convertScaleAbs(edge_x) abs_y = cv2.convertScaleAbs(edge_Y)# 將兩者取絕對值相加，獲得完整影像edge_all = cv2.addWeighted(abs_x, 0.5, abs_y, 0.5, 0)result_img.append(edge_all)關於高斯模糊和索伯算子，日後我想寫篇文章給他們。3/ 素描線條畫像這裡簡單的使用 bitwise_not() 將邊緣成分圖黑白相反，使其看起來像素描：sketch_img = cv2.bitwise_not(edge_all)result_img.append(sketch_img)最後使用 show_img() 展示成果。總結本篇使用高斯模糊去除雜訊、索伯算子提取邊界、bitwise_not()進行黑白反轉。 邊界提取是很實用的東西，例如分辨一張圖畫是寶可夢還是數碼寶貝 等。參考資料 Day12-當自動駕駛遇見AI-索伯算子(Sobel Operator) 邊緣偵測 - 索伯算子 ( Sobel Operator ) Opencv学习—-Opencv宏定义(CV_8U、CV_8S、CV_16U…) 程式語言-看盤版面(上)-圖框教學 在 Matplotlib 中隱藏座標軸、邊框和空白" }, { "title": "影像處理小白（一）：建立滑桿以旋轉圖片、裁切圖片", "url": "/posts/image_crop_and_rotate/", "categories": "Python, 影像處理", "tags": "Python, OpenCV, image processing, rotate image, trackbar", "date": "2023-03-10 19:30:00 +0800", "snippet": " 本系列將紀錄影像處理小白從 0 開始學習 Python x OpenCV 的過程這是學校選修課的功課紀錄，同步發布於 該課程 Blogger 功課要求撰寫一個程式將一張圖像的 (a)整張圖像 (b)中心內切圓區域 旋轉一個角度（逆時針旋轉 0 度至 359 度）：利用一個滑動條(trackbar)控制旋轉角度。成果透過滑動滑桿調整整張圖片的旋轉角度透過滑桿調整內切圓半徑與旋轉角度開發環境 OS Editor Language OpenCV Windows 10 Visual Studio Code Python 3.9.16 OpenCV 4.5.4 做法 本次程式碼： 旋轉整張圖像 旋轉中心圓形旋轉整張圖像這個的想法非常簡單，取得特定圖像的旋轉矩陣後把整張圖片乘上旋轉矩陣後就好。flowchart TDA[建立視窗顯示圖片與 Trackbar] --&amp;gt; B[Trackbar 監測是否有被滑動]B --&amp;gt; C[滑動時執行旋轉]C --&amp;gt; D[將旋轉後的圖片顯示於視窗中]D --&amp;gt; B旋轉圖像所以我寫了一個 Function 好讓 Trackbar 可以重複執行旋轉的動作：def rotate_img(val): global origin_img, result_img (h, w, d) = origin_img.shape # 讀取圖片大小 center = (w // 2, h // 2) # 找到圖片中心 # 取得旋轉矩陣 M = cv2.getRotationMatrix2D(center, val, 1.0) print(val) result_img = cv2.warpAffine(origin_img, M, (w, h)) cv2.imshow(&quot;Rotate Image&quot;, result_img)建立 Trackbar至於 Trackbar 的建立也非常簡單： 利用 imshow 顯示目前的圖片，再使用 createTrackbar 在該視窗建立滑動條。 createTrackbar 的參數分別是 滑桿名稱 , 視窗名稱 , 最小值 , 最大值 , 滑動時要執行的函式cv2.imshow(&quot;Rotate Image&quot;, result_img)cv2.createTrackbar(&quot;degree&quot;, &quot;Rotate Image&quot;, 0, 359, rotate_img)如此一來就建立了一個這樣的視窗：利用 imshow 和 createTrackbar 產生的 GUI 視窗旋轉中心圓形區域切圓形實在不是那麼直觀，透過建立一個 Mask 作為遮罩，來協助我們裁切特定圖片區域。 流程圖如下：flowchart TDA[建立視窗與滑桿]A --&amp;gt; B[旋轉角度滑桿滑動] --&amp;gt; D[&quot;將值存進 bar_degree 變數中&quot;]A --&amp;gt; C[裁切圓形半徑滑桿滑動] --&amp;gt; E[&quot;將值存進 bar_radius 變數中&quot;]D --&amp;gt; F[&quot;根據 bar_radius 建立一個圓形遮罩&quot;]E --&amp;gt; FF --&amp;gt; G[&quot;利用 bitwise_and 裁切出圓形區域，並根據 bar_degree 旋轉該區域&quot;]G --&amp;gt; H[根據 bar_radius 再次建立圓形遮罩]H --&amp;gt; I[這次使用 bitwise_not 裁切掉中心區域的圓形部分]I --&amp;gt; J[使用 bitwise_or 將旋轉後也裁切好的圖片結合]J --&amp;gt; K[顯示結果於視窗中]旋轉中心圓區域首先必須先找到中心圓區域做旋轉： 利用 np.zeros_like(origin_img) 製作一個和原圖片相同尺寸的全黑圖片。（其中 np 為 numpy） 利用 cv2.circle(img, center, radius, color, thickness) 在剛剛的全黑畫布上畫一個實心白色圓形，生成一個圓形遮罩 img : 要用來畫圓的圖片 center : 圓心座標 (X, Y) radius : 圓的半徑 color : 圓的顏色 (B, G, R) thickness : 圓的框線粗細，以 px 為單位，設為 -1 會填滿整個圓 把圓形遮罩拿來和原圖 cv2.bitwise_and(src1, src2[, dst[, mask]]) 後，由於剛剛的圓形遮罩只有中心圓形部分有值（白色），所以進行 AND 後能得到原圖的中心圓形部分。 src1 , src2 : input dst : output mask : 指定要使用 src1 和 src2 的哪些位置來做運算，是一個 8-bit 單通道 array 關於參數中的 [] ，那代表參數可以自行選擇要不要填，並非必要參數，可以參考 這篇文章 再來就能把這個圓形圖片丟到剛剛提到的旋轉函式裡了！def crop_circle(radius): global origin_img (h, w, d) = origin_img.shape # 讀取圖片大小 center = (w // 2, h // 2) # 產生 mask mask = np.zeros_like(origin_img) mask = cv2.circle(mask, center, radius, (255,255,255), -1) # 取得圓形圖片 crop = cv2.bitwise_and(origin_img, mask) return crop結合旋轉後的圓到原圖上再來就是將旋轉完的圓形貼回原圖，這裡一樣要用到圓形遮罩來實現。 像剛剛一樣畫一個黑底的白色圓形圖片 使用 cv2.bitwise_not(src[, dst[, mask]]) 將整個圖片的黑白翻轉，這樣就得到中心為黑色但四周為白色的遮罩。 使用 cv2.bitwise_and(src1, src2[, dst[, mask]]) 擷取圖片外圍，並利用 cv2.bitwise_or(src1, src2[, dst[, mask]]) 結合兩張圖片，產生最終結果。 def combine_img(center_img, radius): global origin_img (h, w, d) = origin_img.shape # 讀取圖片大小 center = (w // 2, h // 2) # 產生 mask mask = np.zeros_like(origin_img) mask = cv2.circle(mask, center, radius, (255,255,255), -1) mask = cv2.bitwise_not(mask) # 取得圓形圖片 crop = cv2.bitwise_and(origin_img, mask) # 結合兩張圖片 combined_img = cv2.bitwise_or(center_img, crop) return combined_img總結本篇利用 OpenCV 進行簡單的圖片旋轉與裁切，作為 OpenCV 和影像處理入門是非常友善的！ 推薦想接觸影像處理領域的人嘗試。參考資料 howarder3/ironman2020_OpenCV_photoshop 加入滑桿 ( Trackbar ) How to use OpenCV to crop circular image?" }, { "title": "利用 Github Actions 自動連結其他 Blog 的 RSS", "url": "/posts/automatic_link_to_other_blog/", "categories": "日常碎碎唸", "tags": "Github, Github Actions, workflow, YAML, Ruby, RSS", "date": "2023-02-05 20:30:00 +0800", "snippet": "在上篇 將其他 blog 的文章連結到 Jeykyll blog 使用了手動的方式下載 RSS 檔案，並在本地端執行完 feeds.rb 後再 push 到 Github 上。 文末也提到我希望全自動執行這個動作，時隔半年，在各方取捨之下終於做出了一個能符合我八成需求的 workflow 了。 由於我本人也不太會 Github Action 的撰寫，主要是用拼湊的完成這次的 code ，所以這裡不會深入講解 workflow 中的語法。 如有錯誤或不精確的部分，歡迎到文章最下方留言指教。流程我們要自動執行的流程如下：flowchart LRA[自動下載指定的&amp;lt;br&amp;gt;RSS 檔並儲存] --&amp;gt; B[執行 feeds.rb 產生&amp;lt;br&amp;gt;markdown 檔案]--&amp;gt; C[將 markdown 檔案 push 回&amp;lt;br&amp;gt; Github repo 中]--&amp;gt; D[將 repo 中的檔案&amp;lt;br&amp;gt; deploy 上網站]我將依照這個順序分享我是怎麼利用 Github Action 達成目標。 完整的 code 我會附在最下面一、自動下載指定的 RSS 檔並儲存這裡我找到了一個 action 可以幫忙下載網路上的檔案進 Github repo 中： wow-actions/download-upload。 這樣使用它： 在 url 中填上要下載的檔案網址。 在 dir 中寫上檔案下載後的儲存路徑。 在 filename 中填寫下載下來的檔案名稱。 - uses: wow-actions/download-upload@v1 with: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} url: &quot;https://blog.ryankert.cc/atom.xml&quot; dir: assets/friends_file/ filename: RyanKert.xml二、執行 feeds.rb 產生 Markdown 檔案這一步驟會讓 feeds.rb 來解析 RSS ，產生相應的 markdown 以供 friends 頁面 使用。 關於 feeds.rb 可以參照 上一篇 。Github Action 運作機制帶來的問題這裡出現了一個小問題， Github Action 的執行大致上是：flowchart LRA[Copy 一份 repo 的檔案] --&amp;gt; B[到遠端主機執行 workflow]簡單來說就是我們的遠端主機並沒有在上一步驟下載的新檔案，它被存在 Github 的 repo 中。 所以這裡我使用了另一個 job: generate-md-file-for-rss ，希望這個步驟可以在上一步驟下載完後重新 copy 一份 repo 中的 code。 同時必須新增 needs 變數來讓這個 job 接續在上一個 job: download-feed-file-automatically 之後執行。 否則它們預設是平行執行的，新的 job 會比舊的 job 還要早被執行。 註：這裡我其實不太確定原理是不是真的這樣運作，反正分開跑是 ok 的。generate-md-file-for-rss: needs: download-feed-file-automatically執行 feeds.rb再來就能安心執行 feeds.rb 了！在 Github Action 中是可以直接使用 run: &amp;lt;command&amp;gt; 來直接執行指令的，但這裡因為要執行 Ruby 檔案，必須要先進行設定。 Ruby 官方有提供專門的設定： ruby/setup-ruby ， 我們可以很簡單的使用它。 設定完成後就可以直接執行 ruby 檔了。 - name: setup ruby uses: ruby/setup-ruby@v1 with: ruby-version: 3.1 # Not needed with a .ruby-version file- name: install bundle run: bundle install- name: run feeds.rb run: ruby feeds.rb三、將 Markdown 檔案 Push 回 Github Repo 中如前面所說，我們是在遠端主機操作一份 copy 下來的 repo ，所以我們對他進行任何變更都不會變動到還在 Github 上的 repo 。 就好像我們從 Github 上 pull 下檔案並修改後，修改完的檔案依舊存在 local 端，不會動到 Github 上的檔案。 而要讓他進行變動當然就是使用 push 功能。 這裡搭配 ad-m/github-push-action 來實現這個功能。 和平常使用 git 一樣，必須先 commit 才能 push ， 在 github_token 中特地使用自己的 personal token 是為了下一步做準備：- name: Commit files run: | git config --local user.email &quot;41898282+github-actions[bot]@users.noreply.github.com&quot; git config --local user.name &quot;github-actions[bot]&quot; git add ./_friends_link git commit -a -m &quot;Automatic add file from workflow&quot; - name: Push changes uses: ad-m/github-push-action@master with: github_token: ${{ secrets.PERSONAL_TOKEN }} branch: ${{ github.ref }} force: true四、將 Repo 中的檔案 Deploy 上網站更新完檔案後我們就可以直接執行原本 blog 的 deploy 了，我的主題 Chirpy 有幫我寫好 deploy 的 Action，會在 push 時自動執行。 然而 Github Action 官方文件 中提到由 repo 的 GITHUB_TOKEN 來觸發的 push 不會被當作一般 push 看待，所以原本的 deploy 會偵測不到在上一步驟執行的 push 。 當然官方也給了解決方法，就是讓 Github 以為是人類 push 就好了。 使用 Personal Tokenpersonal token 是一個替代帳密的方式，利用這個 token 我們可以以自己的身份（以我為例就是 titaliu1224）來操作 Github 上的功能。 利用 官方文件：Creating a personal access token 產生 token 後，再參照 官方文件：Encrypted secrets 將 token 新增至 repo 的 secret 中，我將它命名為 PERSONAL_TOKEN 。 關於 token 在 github-push-action 中所使用的權限可以參照 他們的 issue ，我們可以和他們選擇相同的權限。 這樣就能使用 personal token 來誤導（？） Github Action 了！ 在 workflow 幫我們 push 完，原本的 deploy workflow 就會跟著自動執行，完成我們的朋友貼文更新。Commit 產生的錯誤若目前沒有任何朋友發新文章， feeds.rb 就不會產生新的 markdown ，從而導致 _friends_link 中沒有新增檔案，這將會導致 commit 出現類似的錯誤訊息：Your branch is up to date with &#39;origin/main&#39;.Error: Process completed with exit code 1.我認為這個 bug 暫時不需要修改，在這個 bug 出現時代表不需要 push ，而他也不會 push ，這樣就不會觸發到網站 deploy 的 workflow ，導致不必要的執行。 結語如此便完成自動下載 feed 檔，並將其 deploy 到網站上啦！ 過了半年終於把這個功能給用好，往後一個月就來觀察一下他有沒有好好運作啦～ 如果對我的文章感興趣歡迎訂閱我的 RSS ，或是點擊左下角的 圖標來查看。完整程式碼name: &#39;Automatic build for downloading feed&#39;on: schedule: # Run workflow automatically - cron: &#39;0 * * * *&#39; # Runs every hour, on the hour workflow_dispatch: # Run workflow manually (without waiting for the cron to be called), through the Github Actions Workflow page directlyjobs: download-feed-file-automatically: name: Update this feed files for friends runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: wow-actions/download-upload@v1 with: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} url: &quot;https://tigercosmos.xyz/atom.xml&quot; dir: assets/friends_file/ filename: tigercosmos.xml - uses: wow-actions/download-upload@v1 with: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} url: &quot;https://blog.ryankert.cc/atom.xml&quot; dir: assets/friends_file/ filename: RyanKert.xml generate-md-file-for-rss: needs: download-feed-file-automatically name: transfer rss to markdown runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 with: token: ${{ secrets.PERSONAL_TOKEN }} - name: print directory run: ls -al - name: setup ruby uses: ruby/setup-ruby@v1 with: ruby-version: 3.1 # Not needed with a .ruby-version file - name: install bundle run: bundle install - name: run feeds.rb run: ruby feeds.rb - name: Commit files run: | git config --local user.email &quot;41898282+github-actions[bot]@users.noreply.github.com&quot; git config --local user.name &quot;github-actions[bot]&quot; git add ./_friends_link git commit -a -m &quot;Automatic add file from workflow&quot; - name: Push changes uses: ad-m/github-push-action@master with: github_token: ${{ secrets.PERSONAL_TOKEN }} branch: ${{ github.ref }} force: true " }, { "title": "LeetCode: 14. Longest Common Prefix", "url": "/posts/LeetCode_14_Longest_Common_Prefix/", "categories": "LeetCode, Easy", "tags": "LeetCode, string, C++", "date": "2023-01-27 05:21:00 +0800", "snippet": "好久沒有寫 code 了，趁年節期間回憶一下 C++，結果一路上我各種忘記宣告、分號，看來是 Python 中毒了 題目本人點我本題 github題目概述輸入：一個含有 1 ~ 100 個字串的 vector 輸出：vector 中最長的 common prefix string 例如：Input: strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot;我的做法一開始我很不想使用雙層迴圈來寫，結果執行時間意外的短？ 本題的 LeetCode 成績單我的想法非常簡單，把每一個字串抓出來跟第一個字串比對從第一個字比對到最後一個字，只要一有不符合的就跳出迴圈，並記錄長度。class Solution {public: string longestCommonPrefix(vector&amp;lt;string&amp;gt;&amp;amp; strs) { int biggestCommon = INT_MAX; int commonCount = -1; for (auto it : strs){ commonCount = -1; for (int i = 0; i &amp;lt; it.length(); i++){ if (it[i] == strs[0][i]) commonCount++; else break; } if (commonCount &amp;lt; biggestCommon) biggestCommon = commonCount; if(biggestCommon == -1) return &quot;&quot;; } return strs[0].substr(0, biggestCommon + 1); }};這裡使用到我以前沒使用過的 range-based loop ，有點像 Python 裡的 for it in strs 要寫成這樣的迴圈重點就是那個 : 在我的程式碼中 it 會遍歷strs中的每個 string ， 而裡面的迴圈會比對 it 裡的每一個字是否和 strs[0] 中相同。而 auto 這個東西就有點像是 js 中的 var, let 一樣，不用特別指定型別是 int 還是 vector &amp;lt;int&amp;gt; :: iterator ，只要有使用 = 來給定值就可以免去宣告型別的麻煩。至於型別的部分會交由編譯器去判斷，所以並不會影響實際執行的結果。例如：// 也就是 int x = 1;auto x = 1;// 也就是 double y = sin(1.3);auto y = sin(1.3); 結語很適合剛學 C++ 的人來寫這題，理解一下迴圈和字串是什麼。" }, { "title": "在 PowerShell 中使用 Conda 建立 Python 虛擬環境", "url": "/posts/change_python_version_in_conda/", "categories": "Python, 學習日誌", "tags": "Python, conda, virtual-environment, PowerShell, learning", "date": "2022-12-26 09:36:00 +0800", "snippet": "最近終於想要告別 Python 小白的身分，來好好的學學 machine learning 的部分（過了一學期依舊是一個沒用的專題仔），所以才在試著使用 conda。 這裡就記錄一下我今天使用到的指令。環境 OS commandLine Windows 10 PowerShell 7.3.1 我本身的 PowerShell 有使用套件 Oh-My-Posh 來套用主題美化，所以可能會和大家電腦上看到的不太一樣。使 PowerShell 能使用 Conda在 PowerShell 中輸入指令：conda init powershell執行起來大致上會長這樣執行完再重啟 PowerShell 就可以了。建立虛擬環境 利用 conda create 來建立虛擬環境，並指定名字為 tensorflow-test ，Python 版本為 3.9 conda create --name tensorflow-test python=3.9 利用 conda env list 查看當前有哪些虛擬環境 (base 3.8.3) C:\\Windows\\System32 ❯ conda env list # conda environments: # base * C:\\Users\\tiffa\\anaconda3 tensorflow-test C:\\Users\\tiffa\\anaconda3\\envs\\tensorflow-test 使用 conda activate 來進入虛擬環境 tensorflow-test conda activate tensorflow-test 打開Jupyter Notebook 先用以下指令下載 Jupyter： conda install jupyter conda install ipykernel 註冊一個名為 Tensorflow test 的 Python 環境（這裡的名字主要是自己看著好辨識，沒什麼特別要求） python -m ipykernel install --user --name tensorflow-test --display-name &quot;Tensorflow test&quot; cd 到想打開 Jupyter 的資料夾 cd D:\\Python\\ 打開 Jupyter jupyter notebook 點擊右上角 New &amp;gt; Tensorflow test 打開一個新的 notebook其他 Jupyter 相關指令 查詢有哪些 Python 環境 jupyter kernelspec list 刪除環境 jupyter kernelspec remove &amp;lt;環境名稱&amp;gt; 更正 Python 版本我在建立完虛擬環境後發現 Python 版本和 TensorFlow 要求的不一樣，需要中途更改版本為 Python 3.8：conda install python=3.8安裝完成後使用指令 python 來確認版本（雖然我的主題可以直接看到虛擬環境的版本就是了）(tensorflow-test 3.8.15) C:\\Windows\\System32 ❯ pythonPython 3.8.15 (default, Nov 24 2022, 14:38:14) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&amp;gt;&amp;gt;&amp;gt;執行指令後的第一行可以看到我的版本變成 Python 3.8.15結語建立 Python 虛擬環境其實一點都不難，指令複製貼上就能解決了。" }, { "title": "在 MySQL 中的 table 插入資料（Lv. 2）", "url": "/posts/insert-data-into-table/", "categories": "資料庫學習日誌", "tags": "database, MySQL, web", "date": "2022-08-22 04:04:00 +0800", "snippet": "上一次介紹了特殊的 key 和 VARCHAR 這個資料結構，並用其建立了 table，這次將來插入資料。資料表操作 Lv. 1.5選擇要插入的欄位 指令：INSERT INTO &amp;lt;table&amp;gt; (&amp;lt;column 1&amp;gt;, &amp;lt;column 2&amp;gt;, ...) VALUE (&amp;lt;data 1&amp;gt;), (&amp;lt;data 2&amp;gt;), (&amp;lt;data 3&amp;gt;); 注意事項：若什麼都不指定，就必須填寫所有欄位MySQL[computers]&amp;gt; INSERT INTO objects (type, brand, model) -&amp;gt; VALUE (&#39;2&#39;, &#39;logitech&#39;, &#39;G502&#39;), -&amp;gt; (&#39;3&#39;, &#39;corsair&#39;, &#39;MK.2&#39;), -&amp;gt; (&#39;1&#39;, &#39;ASUS&#39;, &#39;VG247Q1A&#39;);顯示 table 建構資訊 指令：SHOW CREATE TABLE &amp;lt;table&amp;gt;\\G 注意事項 將顯示 table 未填資料時的預設內容 key 將在最後顯示 最後的 ENGINE 是 table 採用的儲存引擎型態，InnoDB 是一種交易安全表，有一支持一些加密動作 CHARSET 是預設字元集，utf8 可以解析英文以外的語言，例如中文 在調整過一些預設職之後，使用此指令可以檢視結果 MySQL[computers]&amp;gt; SHOW CREATE TABLE objects \\G*************************** 1. row *************************** Table: objectsCreate Table: CREATE TABLE `objects` ( `object_id` int NOT NULL AUTO_INCREMENT, `type` int DEFAULT NULL, `brand` varchar(20) DEFAULT NULL, `model` varchar(20) DEFAULT NULL, `description` text, PRIMARY KEY (`object_id`), UNIQUE KEY `model` (`model`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci1 row in set (0.00 sec)再來我建立了幾個 table 練練手，各位也能自己試試看： 用戶email與名字 type_id，對應鍵盤、滑鼠、螢幕等總結以下是建構 tables 應該考慮的點 可以用多個 table 來存放不同的物品，並使用 key 來連接，如此便能減少錯誤並提升統一性 一個欄位可以有很多種不同的屬性" }, { "title": "在 MySQL 中建立 table （小進階）", "url": "/posts/create-tables/", "categories": "資料庫學習日誌", "tags": "database, MySQL, web", "date": "2022-08-22 04:04:00 +0800", "snippet": "上次我們學會如何建立資料庫與資料表並插入一些資料，這次將更深入了解資料表如何操作。規劃資料架構的基本要素在建立 table 前建議先規劃這些； 資料庫有幾個資料表、分別要叫什麼名字 每個資料表要有多少欄位和欄位的名稱 每個欄位要儲存什麼型態的資料資料庫操作 Lv. 1.5刪除資料庫 指令：DROP DATABASE &amp;lt;database&amp;gt; 注意事項：我將會以電腦周邊當作要儲存的資料MySQL[(none)]&amp;gt; CREATE DATABASE computers;Query OK, 1 row affected (0.03 sec)MySQL[(none)]&amp;gt; DROP DATABASE computers;Query OK, 0 rows affected (0.01 sec)資料表操作 Lv 1 - 建立 table首先創立一個資料表，我將會一一解釋其中內容。MySQL[computers]&amp;gt; CREATE TABLE objects ( -&amp;gt; object_id INT AUTO_INCREMENT, -&amp;gt; type INT, -&amp;gt; brand VARCHAR(20), -&amp;gt; model VARCHAR(20) UNIQUE, -&amp;gt; description TEXT, -&amp;gt; PRIMARY KEY (object_id) -&amp;gt; );Query OK, 0 rows affected (0.03 sec)使用 DESCRIBE &amp;lt;table&amp;gt; 來查看 table:MySQL[computers]&amp;gt; DESCRIBE objects;+-------------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------------+-------------+------+-----+---------+----------------+| object_id | int | NO | PRI | NULL | auto_increment || type | int | YES | | NULL | || brand | varchar(20) | YES | | NULL | || model | varchar(20) | YES | UNI | NULL | || description | text | YES | | NULL | |+-------------+-------------+------+-----+---------+----------------+5 rows in set (0.00 sec)Object_idobject_id 將作為主要鍵值欄位，所以有關鍵字 PRIMARY KEY 。我想就是之後要搜尋特定物品時將使用這個 id 做連結的意思吧。而 AUTO_INCREMENT 則是代表這個區塊的值要自動遞增，預設起始值為1。 可以在這裡看 W3School 的 PRIMARY KEY 教學type這裡將儲存此物品的種類，如螢幕、鍵盤、滑鼠等，以 INT 表示，方便輸入也預防打錯。brand這將儲存品牌的名字。VARCHAR 和 CHAR 不同的地方是，當使用 CHAR(10) 只有輸入 hi 兩個字時，CHAR 將會自動補上8個字來填滿設定的 CHAR(10)。但 VARCHAR 將不會以空格填滿，而是只使用2個字的空間（2 bytes）來儲存資料。另外還有 NCHAR 和 NVARCHAR，他們將以 unicode 編碼，每個字元占用2 bytes，雖花了更多空間，但如此便能儲存中文、日文、韓文等非英文資料。 參考資料：[iT鐵人賽Day6]SQL Server 資料型態 char varchar nchar nvarcharmodel將儲存該物品的型號。UNIQUE 將會確保該欄的每一個值都不會重複，而前面提過的 PRIMARY KEY 自帶 UNIQUE 的屬性。description將填寫物品的詳細資料，使用 TEXT 就不怕字數上限的問題，他的行為就好像 C++ 中的 string 一樣，會隨著使用者輸入的資料長度變化它所需的儲存空間。DESCRIPTION &amp;lt;table&amp;gt; 在使用 DESCRIPTION &amp;lt;table&amp;gt; 後，第三欄（Null）表示是否允許值為NULL。 第四欄（key）將會顯示該欄位是否有索引存在，將以簡寫表示，如： PRI 是 PRIMARY KEY UNI 是 UNIQUE 第五欄（Default） 表示該欄是否有預設資料值，但我們在建立時沒有指定預設資料所以這裡為 NULL。 最後一欄（Extra）會記錄欄位的額外資訊。資料表操作 Lv. 1.2 - 修改 table雖然前面有提到我們應該要設計好 table 再來建立，但 MySQL 仍有一些方法可以修正打錯的資料。小提示，要修改就要趁早，不然 data 輸入後再修改可能會造成很多麻煩。增加一個欄位 指令：ALTER TABLE &amp;lt;table&amp;gt; ADD &amp;lt;column_name&amp;gt; &amp;lt;data_type&amp;gt; 注意事項：將會新增為最後一個欄位MySQL[computers]&amp;gt; ALTER TABLE objects -&amp;gt; ADD color VARCHAR(10);Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0刪除一個欄位 指令：ALTER TABLE &amp;lt;table&amp;gt; DROP &amp;lt;column_name&amp;gt; 注意事項：無MySQL[computers]&amp;gt; ALTER TABLE objects -&amp;gt; DROP color;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0修改欄位的資料型態 指令：ALTER TABLE &amp;lt;table&amp;gt; MODIFY &amp;lt;column_name&amp;gt; &amp;lt;data_type&amp;gt; 注意事項：只能修改資料型態，不能修改欄位名。MySQL[computers]&amp;gt; ALTER TABLE objects -&amp;gt; MODIFY color INT;Query OK, 0 rows affected (0.06 sec)Records: 0 Duplicates: 0 Warnings: 0其他修改方式可以使用 DROP 指令刪除整個資料庫，再使用 CREATE 指令 來重新建立一次資料庫，以修改打錯的名字或多筆資料。而途中可以使用方向鍵上鍵來快速輸入以前輸入的資料。恭喜完成這篇比較短，只建立好一個 table，下篇就來插入資料囉Reference本篇內容皆來自 MySQL 與 MariaDB 學習手冊 與 W3School" }, { "title": "將其他 blog 的文章連結到 Jeykyll blog", "url": "/posts/link_to_other_blog/", "categories": "日常碎碎唸", "tags": "Jekyll, Ruby, RSS, HTML, web", "date": "2022-08-18 09:44:00 +0800", "snippet": "一直都很想要把 medium 的一些舊文章和朋友的文章引用進自己的 blog，這樣就能在我沒有更新的時候這裡也能有新文章出現，也就是說我要偷懶的意思。本篇將會示範如何在我的 Jekyll 網站中增加一個頁面來顯示其他網站的文章，可能內容和你的主題會有出入，請依照你的狀況做改變。 本篇內容是「手動」下載 RSS 檔案和「手動」 deploy Github page ，如對自動化此流程感興趣請參照 利用 Github Actions 自動連結其他 Blog 的最新貼文事前準備 擁有一個 Jeykyll 網站，並下載了 Ruby 擁有一個 Github，並下載了 Git 找到一個感興趣的網站的 RSS Feed 並下載到電腦中，例如我的這個 blog 什麼是 Feed? Feed 是 Web2.0 的產物，它會顯示一個網站中最近的幾篇文章的概述，好讓人可以整合在一個地方（如 RSS 閱讀器）閱讀各平台的最新資訊。 步驟1: 下載 Jekyll feed importer 首先，下載4個 gem 套件： feed-normalizer: gem install feed-normalizer yaml: gem install yaml -v 0.1.0 to_slug: gem install to_slug sanitize: gem install sanitize 下載Jekyll feed importer 的 feeds.rb 並將其放入網站資料夾中 點開檔案，設定 feed_file 作為你 feed 檔案將會在的位置和 output_location 作為輸出的 markdown 檔案將去的位置。以下為 feed_file 設定： 請先下載你想要匯入的 feed 檔 請建立一個 yaml 檔，名字隨意 依照以下格式一一填上你的 feed 的檔名 - name: Tita&#39;s Medium feed: ./_friends_link/TitaLiu.xml 因為當輸入的文章標題為全中文時會無法順利顯示檔名，所以我自己加了一個變數 count 在每形成一個檔案時 += 1，使每一個檔案都有一個流水號，這個 code 有點難貼上，麻煩各位依照迴圈的邏輯自己加上去 執行 ruby feed.rb，你的目的地 output_location 中應該會出現很多 markdown 檔案，格式為；---title: &quot;碎碎念隨筆（十）：如何在 VSCode 中使用 PowerShell Core 7?&quot;date: 2022-04-18 19:22:47 +0000dateadded: 2022-08-19 00:31:33 +0800description: &quot;&quot;link: &quot;https://medium.com/@TitaLiu/%E7%A2%8E%E7%A2%8E%E5%BF%B5%E9%9A%A8%E7%AD%86-%E5%8D%81-%E5%A6%82%E4%BD%95%E5%9C%A8-vscode-%E4%B8%AD%E4%BD%BF%E7%94%A8-powershell-core-7-3a5d7533b4e4?source=rss-1f0703e3e84b------2&quot;category:---步驟2: 修改 config.yml前往你的 _config.yml 找到 collections: ，並新增一項 friends_link，像這樣：collections: friends_link: people: true步驟3: 複製檔案到 local 端 新增 friends.md 到資料夾 _tabs 複製其他 _tabs 中的內容，並更改 title 和 layout ---layout: friendstitle: Friendsicon: fas fa-userorder: 6--- 前往你的主題的 github &amp;gt; _layouts，複製你想呈現的頁面的 html 檔，檔名通常會和你 _tabs 中其他檔案的 layout 的值相同，例如我的是 archives.html 修改 html 檔，將原本的 site.posts 改成 site.friends_link （即步驟2中設定的 collections ） Jekyll collection 預設使用 date 由舊到新排序，但我希望新的是第一個，修改了一下（請自行補上 % ，我直接打出來會出錯）： { assign sorted = site.friends_link | reverse } { for post in sorted } ...other code { endfor } 理論上他要運作得很完美了！（我是隔一天才打這篇文章的，若有缺漏可以告訴我，感謝！）結語目前為止應該都能用手動方式跑出朋友的文章了！ 我原本想要研究使用 github workflow 下載文章並執行 feedds.rb，可惜在下載 Medium 的 feed 時出了一點小狀況，而且要利用 workflow 來執行檔案實在有點複雜，只能再研究看看了。" }, { "title": "在 MySQL 資料庫中新建一個 Table", "url": "/posts/create_a_new_table_in_MySQL/", "categories": "資料庫學習日誌", "tags": "database, MySQL, web", "date": "2022-08-17 03:22:00 +0800", "snippet": "本系列將以流水帳形式記錄我用到的指令和走過的軌跡，順便當小鐵人賽XD 我將會以一個純資料庫新手的角度說說我學到的東西，若有錯誤歡迎指正。以下是我使用的工具： OS MySQL server version Windows 10 8.0.30 事前準備 已建立好非 root 帳號 使用該帳號登入用戶端文字介面mysql，指令：mysql -u &amp;lt;user&amp;gt; -p 我使用指令 prompt MySQL [\\d]&amp;gt;\\_ 將我的命令輸入提示更改成 MySQL [test]&amp;gt; ，其中 \\d 為預設資料庫，\\_ 為空格，以下示範： mysql&amp;gt; prompt MySQL [\\d]&amp;gt;\\_PROMPT set to &#39;MySQL [\\d]&amp;gt;\\_&#39;MySQL [(none)]&amp;gt; 資料庫操作 Lv. 1查詢伺服器中的 database 們 指令：SHOW DATABESES; 注意事項 是 databases，不是 database 每句句尾都要加上分號 MySQL [(none)]&amp;gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sakila || sys || world |+--------------------+7 rows in set (0.00 sec)SQL 指令 Lv. 1: 建立資料庫與資料表建立一個 database 指令： CREATE DATABASE &amp;lt;name&amp;gt;; 注意事項：資料庫名稱通常是小寫MySQL [(none)]&amp;gt; create database test;Query OK, 1 row affected (0.01 sec)建立一個 table 指令：CREATE TABLE &amp;lt;database.table&amp;gt; (&amp;lt;欄位&amp;gt; &amp;lt;型別&amp;gt;, &amp;lt;欄位2&amp;gt; &amp;lt;型別2&amp;gt;, ...); 注意事項：關於型別可以看這裡MySQL [(none)]&amp;gt; create table test.books (book_id INT, title TEXT, status INT);Query OK, 0 rows affected (0.02 sec)查看 database 中的 tables 指令：SHOW TABLES FROM &amp;lt;database&amp;gt;; 注意事項：無 小心得：一個資料庫就像是一份 Google Sheet，裡面可以建立多個資料表，像是資料庫中的 table 一樣，而這一整個 server 就是包含多個 Google sheet 的資料夾（不說 Excel 是因為我沒用過 Excel，誰叫它要錢~）MySQL [(none)]&amp;gt; show tables from test;+----------------+| Tables_in_test |+----------------+| books |+----------------+設定預設資料庫使不用每次都打上資料庫名稱 指令：USE &amp;lt;database&amp;gt;; 注意事項：若在 prompt 中有使用 \\d 的話，這時 prompt 會產生變化MySQL [(none)]&amp;gt; use testDatabase changedMySQL [test]&amp;gt; 如此一來便不需打上 table 名稱了：MySQL [test]&amp;gt; show tables;+----------------+| Tables_in_test |+----------------+| books |+----------------+1 row in set (0.00 sec)查看 tables 中的資料 指令：DESCIRBE &amp;lt;table&amp;gt;; 注意事項：我們還未放入任何資料MySQL [test]&amp;gt; describe books;+---------+------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+---------+------+------+-----+---------+-------+| book_id | int | YES | | NULL | || title | text | YES | | NULL | || status | int | YES | | NULL | |+---------+------+------+-----+---------+-------+3 rows in set (0.00 sec)SQL Lv. 2: 插入與處理資料在 talbe 中插入資料 指令：INSERT INTO &amp;lt;table&amp;gt; VALUES(&amp;lt;data1&amp;gt;, &amp;lt;data2&amp;gt;, &amp;lt;data3&amp;gt;); 注意事項 大小寫與空格不影響指令的執行 須按照創建時的欄位順序填寫值 MySQL [test]&amp;gt; insert into books VALUES(100, &#39;Heart of Darkness&#39;, 0);Query OK, 1 row affected (0.01 sec)一次插入多筆資料 指令：INSERT INTO &amp;lt;table&amp;gt; VALUES(&amp;lt;data1&amp;gt;, &amp;lt;data2&amp;gt;, &amp;lt;data3&amp;gt;), (&amp;lt;data4&amp;gt;, &amp;lt;data5&amp;gt;, &amp;lt;data6&amp;gt;); 注意事項：無MySQL [test]&amp;gt; insert into books VALUES(101, &#39;Hello World is a mysterious spell&#39;, 1), (102, &#39;Mozambique Here&#39;, 0);Query OK, 1 row affected (0.00 sec)查看 table 中的資料 指令：SELECT * FROM &amp;lt;table&amp;gt;; 注意事項 * 表示「全部、所有」，關於正則表達式 將 * 改成欄位名稱即可顯示特定欄位 MySQL [test]&amp;gt; SELECT * FROM books;+---------+-----------------------------------+--------+| book_id | title | status |+---------+-----------------------------------+--------+| 100 | Heart of Darkness | 0 || 101 | Hello World is a Mysterious Spell | 1 || 102 | Mozambique Here | 0 |+---------+-----------------------------------+--------+3 rows in set (0.00 sec)篩選資料 指令：SELECT * FROM &amp;lt;table&amp;gt; WHERE &amp;lt;條件式&amp;gt;; 注意事項 是 = 不是 ==，關於比較運算子 假設這裡的 status 代表剩餘庫存與否 MySQL [test]&amp;gt; SELECT * FROM books WHERE status = 1;+---------+-----------------------------------+--------+| book_id | title | status |+---------+-----------------------------------+--------+| 101 | Hello World is a Mysterious Spell | 1 |+---------+-----------------------------------+--------+1 row in set (0.00 sec)以卡片方式顯示資料 指令：句尾不使用 ; 而是 \\G 注意事項 此方法當表格過長導致換行或排版跑掉時很好用 若是小寫的 \\g，行為會和 ; 一樣 MySQL [test]&amp;gt; SELECT * FROM books WHERE status = 0 \\G*************************** 1. row ***************************book_id: 100 title: Heart of Darkness status: 0*************************** 2. row ***************************book_id: 102 title: Mozambique Here status: 02 rows in set (0.00 sec)修改資料 指令：UPDATE &amp;lt;table&amp;gt; SET &amp;lt;資料名稱&amp;gt; = &amp;lt;值&amp;gt; WHERE &amp;lt;條件式&amp;gt;; 注意事項：無MySQL [test]&amp;gt; UPDATE books SET title = &#39;A Server Made of Potato&#39; WHERE book_id = 102;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0一次修改兩筆資料 指令：UPDATE &amp;lt;table&amp;gt; SET &amp;lt;資料名稱&amp;gt; = &amp;lt;值&amp;gt;, &amp;lt;資料名稱2&amp;gt; = &amp;lt;值2&amp;gt; WHERE &amp;lt;條件式&amp;gt;; 注意事項：以空格隔開要修改的值MySQL [test]&amp;gt; UPDATE books SET title = &#39;The Secret of Hello World&#39;, status = 0 WHERE book_id= 101;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0MySQL [test]&amp;gt; SELECT * FROM books;+---------+---------------------------+--------+| book_id | title | status |+---------+---------------------------+--------+| 100 | Heart of Darkness | 0 || 101 | The Secret of Hello World | 0 || 102 | A Server Made of Potato | 1 |+---------+---------------------------+--------+3 rows in set (0.00 sec)Character 指令：CHAR(&amp;lt;SIZE&amp;gt;) 注意事項：使用字元集來限制字串長度，使資料用起來更有效率，當資料一多的時候會顯示出差異MySQL [test]&amp;gt; CREATE TABLE status_names (status_id INT, status_name CHAR(8));Query OK, 0 rows affected (0.01 sec)這裡順便插入資料使我們可以對照 books 中的 status 是什麼意思：MySQL [test]&amp;gt; INSERT INTO status_names VALUES(0, &#39;Incative&#39;), (1, &#39;Active&#39;);Query OK, 2 rows affected (0.00 sec)Records: 2 Duplicates: 0 Warnings: 0MySQL [test]&amp;gt; SELECT * FROM status_names;+-----------+-------------+| status_id | status_name |+-----------+-------------+| 0 | Incative || 1 | Active |+-----------+-------------+2 rows in set (0.00 sec)結合兩個 table 指令： &amp;lt;table1&amp;gt; JOIN &amp;lt;table2&amp;gt; 注意事項 不用 * 來挑選欄位是因為會出現一些不需要的欄位（如：status, status_id） 使用 JOIN 就能一次選擇兩種 table 中的欄位 在打上分號前不論怎麼換行都沒關係 會在 books 中使用 status = 0 or 1 是因為這樣可以讓資料比較簡潔也避免出錯（例如打錯英文字） 若兩個 table 有一樣名字的欄位，必須寫成 &amp;lt;database1&amp;gt;.&amp;lt;table&amp;gt; JOIN &amp;lt;database2&amp;gt;.&amp;lt;table&amp;gt; MySQL [test]&amp;gt; SELECT book_id, title, status_name -&amp;gt; FROM books JOIN status_names -&amp;gt; WHERE status = status_id;+---------+---------------------------+-------------+| book_id | title | status_name |+---------+---------------------------+-------------+| 100 | Heart of Darkness | Incative || 101 | The Secret of Hello World | Incative || 102 | A Server Made of Potato | Active |+---------+---------------------------+-------------+3 rows in set (0.00 sec)恭喜完成現在就去建立自己的表格吧！ 請輸入 quit 登出後重新登入一次 請試著建立以下2個 tables 請試著使用 relatoinship 篩選出關係為 Friend 的人並顯示+---------+------------+--------------+----------------------+-------------+| name | phone_work | phone_mobile | email | relation_id |+---------+------------+--------------+----------------------+-------------+| Tita | 0227858593 | 0965789597 | tita@gmail.com | 1 || Richard | 0356459812 | 0955558623 | rrrrichard@hello.com | 2 || Benny | 055432124 | 0964487598 | bbb@yeah.com | 2 || Jenny | 0667841325 | 0954123465 | jennychen@mail.com | 3 || Ikea | 024128869 | 0922245678 | IkeaIsIkea@ikea.com | 1 |+---------+------------+--------------+----------------------+-------------++-------------+--------------+| relation_id | relationship |+-------------+--------------+| 1 | Family || 2 | Friend || 3 | Colleague |+-------------+--------------+Reference本篇內容皆來自 MySQL 與 MariaDB 學習手冊" }, { "title": "LeetCode: 191. Number of 1 Bits", "url": "/posts/LeetCode_191_Number_of_1_Bits/", "categories": "LeetCode, Easy", "tags": "LeetCode, bit manipulation, Java", "date": "2022-08-04 09:24:00 +0800", "snippet": "剛開始學 Java，當然是要來寫 easy 題啊！ 題目本人點我本題 github題目概述輸入：一個正整數 輸出：該正整數在二進位下有多少個1 注意：因為 Java 沒有 unsigned integer，所以過大的數會以 2’s complement 的形式 overflow。我的做法1一開始我想起資訊概論教的短除法方法：除以2，記下餘數。但是一碰到負數就沒轍了，因為我的迴圈只設計給正數使用。這個方法如果在有 unsigned integer 的語言中應該能行，可惜身為 java 必須改道QQ。// ans 為 1 的數量，n 為輸入的數字int ans = 0;while(n &amp;gt; 0){ ans = ans + ( n % 2 ); n /= 2;}我的做法2既然不能用數學的方法做，只好從 bit 的方向下手。我的想法是：先取最右邊的 bit，再將 n 向右 shift 一位，並用迴圈重複這個流程。但還是沒辦法用 n % 2 來取得最右邊的 bit，所以使用一個我稱它為 “mask” 的方法： n &amp;amp; 1 。 利用和1做 bitwise and 來保留最右 bit 的值 再使用 n &amp;gt;&amp;gt;&amp;gt; 1 做 logical shift 來完成右移一位的動作這裡有個小細節：不能使用 n &amp;gt;&amp;gt; 1 進行 arithmetic shift，這樣如果最右 bit 是1，它將會回到最左邊重新循環，導致數量計算錯誤。這裡先放上成績單：完整 code:public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { int ans = 0; while(n != 0){ ans = ans + ( n &amp;amp; 1 ); n = n &amp;gt;&amp;gt;&amp;gt; 1; } return ans; }}結語這種 bit manipulation 的題目需要一點資訊概論基礎，意外的考驗基本功。題外話，這是我目前寫過成績最好的題目了，好快樂～" }, { "title": "用 Inky 打造自己的文字遊戲吧", "url": "/posts/Inky_escape_game/", "categories": "Projects, 休閒", "tags": "Inky, Ink, game, web", "date": "2022-07-27 00:45:00 +0800", "snippet": "前些日子找出上學期完成一半的密室逃脫，花了幾天把它完成。它是半小時內就能破關的小遊戲，可以前往我的 github page來玩。 以下會有劇情暴雷，請斟酌閱讀Ink 簡介在開始之前，可以到該專案的 github 頁面來查看我的 code。Ink是一個 scripting language，它能使用簡單的語法來編寫以文字為基礎的遊戲。它可以快速產生 html 和 js 檔案，讓你不需要碰到一絲一毫的 js 就能產生一個簡單的網頁。想要編寫 Ink 的話可以用他們的 IDE: Inky 來編寫，在 Inky 中，可以即時看到編寫的結果，非常好用。Ink 基本語法 官方文件點我Ink 的語法真的非常簡單，給我的感覺有點像 markdown，用一些符號來替代程式碼。以下幾個功能可以構成一個小故事： 普通見到的文字只要直接打出來就好，不需要加上任何的 tag 或符號。 或是在句尾加上 &amp;lt;&amp;gt; 來黏著兩行句子 在遊戲中最常見到的選項分為兩種： 只能選擇一次的單次選擇，使用 * 來表示 可以重複選擇的多次選擇，使用 + 來表示 像其他語言的 function 的結構：結（knot），用 === 結的名稱 === 表示。它可以用來命名一個場景或一段劇情，好讓程式從不同的地方進入該場景，或是重複進入。 要跳轉到結的話，就要使用 -&amp;gt; 結的名稱。 請注意，每個選項與結之後都必須要有跳轉。簡單 Demo 1我們能利用這樣簡單的語法來寫出一個小故事：使用 文字敘述 -&amp;gt; 單次選項 -&amp;gt; 跳轉至結 來構成。產生的結果是這樣：先由一段文字當開頭，在選擇選項後利用 -&amp;gt; School 來跳轉到名為 School 的結。在 School 的最後寫上 -&amp;gt; END 來告訴程式你結束了。簡單 Demo 2由於我們沒有重複回到這個場景，所以看不到單次選項的功力。這裡我寫了一個簡單的重複場景，其中每個選項都是單次選擇。每個選項都只能被選擇一次的寫法選過的選項會消失，以推動劇情的進行 另外，我們也能使用複數個 + 和 * 來構成選完選項後出現的第二個分支選項。在這裡，每一個選項都以 * 開頭，使得每次回到 === find_key === 時，不會出現已選過的選項。 選項有三種寫法，一是 * [打招呼] 嗨~、二是 * 嗨[]~、三是 * 嗨~，可以用這個方式來控制按下選項後是否要複誦選項的內容，還有要複誦到哪裡，這裡可以自己嘗試看看～Ink 進階語法這裡不提太複雜的東西（畢竟我也不會），就最簡單的判斷式和可變文本來當示範。判斷式判斷式，也就是 if，在這裡必須使用大括號 {} 括住條件。我最常用的是「是否經過某個結」的功能。它會像是這樣：* {結的名稱} [選項]或是：{結的名稱: 要說的話或是要跳轉}這裡有個小範例，在 === box === 中寫了上述的第一種用法，而 === key === 中寫了第二種用法。 box 中寫了有條件的選項，key 中寫了有條件的一般文字若沒有先拿木盒再拿鑰匙 -&amp;gt; 不出現可以打開木盒的文字若曾去過名為 key 的結 -&amp;gt; 出現「用鑰匙解鎖的選項」可變文本 (variable text)大括號 {} 還能用來做簡單的次數計算和隨機結果，他們的寫法分別為： 照順序跑：用大括號 {} 括起來，並用直線符號 | 隔開，這樣每一次執行到這一行時，就會依照執行過的次數做出相應反應。它寫起來像這樣： {1|2|3|4} 隨機結果：用 {~ 開頭，並用直線符號 | 隔開每一個選項，再用大括號 } 結束，，寫起來是這樣： {~ 1|2|3|4} 分別用兩個結寫照順序功能和隨機功能每次點擊時，都會跑下一個被 | 隔開的內容每次點擊時，隨機出現一個被 | 隔開的內容結語這篇文真的拖了超～～級久的，從密室逃脫完工就開始寫文章，到現在也過了兩個月，時間真的過超快的。這次 blog 的 push 會新增留言功能，希望能夠順利成功不用 debug，拜託拜託（放綠色乖乖" }, { "title": "Java: GridLayout + tic-tac-toe", "url": "/posts/java_grid/", "categories": "Java 學習中", "tags": "Java, awt, windowing, learning, note, game, homework, problem-solve", "date": "2022-05-04 02:16:00 +0800", "snippet": " 這次的功課是使用 AWT(Abstract Windowing Toolkit) 寫出 3*3 的圈圈叉叉，本文將記下我撰寫途中遇到的問題問題1：明明放在前面的 label 卻出現在整個頁面的最下面一列？問題描述我還在嘗試怎麼使用 grid 時，寫了以下的 Code，我先設定並 add label 後，利用迴圈跑出9個按鈕。理論上 Label 應出現在按鈕上方，但他卻出現在底下。Label 出現在 button 後面完整的 code 在這：import java.awt.*;public class hw1 extends Frame{ static Frame frm = new Frame(&quot;Tic-Tac-Toe&quot;); static Label lab = new Label(&quot;It&#39;s \\&quot;O\\&quot; turn.&quot;); public static void main(String args[]){ // 設定版面 GridLayout grid = new GridLayout(4, 3); frm.setLayout(grid); frm.setSize(600, 800); frm.setBackground(Color.white); frm.setLocation(200, 50); // 設定標籤屬性 lab.setBackground(Color.gray); lab.setFont(new Font(&quot;Serief&quot;,Font.BOLD,18)); frm.add(lab); // 按鈕 for(int i = 0; i &amp;lt; 9; i++){ frm.add(new Button(), i); } frm.setVisible(true); }}為何如此？原來問題出在第 21 行，frm.add(new Button(), i);。當 add 有兩個參數時，後面的 int 將會表示顯示的位置。（你可以在這裡找到官方文件的解說）例如我將它改為 frm.add(new Button(Integer.toString(i)), i + 1);，會顯示這樣的結果： 所有 button 從「第一格」（左上角的灰格為第0格）開始依序往下排列修改成果import java.awt.*;public class hw1 extends Frame{ static Frame frm = new Frame(&quot;Tic-Tac-Toe&quot;); static Label lab1 = new Label(&quot;It&#39;s \\&quot;O\\&quot; turn.&quot;); static Label lab2 = new Label(); static Label lab3 = new Label(); public static void main(String args[]){ // 設定版面 GridLayout grid = new GridLayout(4, 3); frm.setLayout(grid); frm.setSize(600, 800); frm.setBackground(Color.white); frm.setLocation(200, 50); // 設定標籤屬性，預留三個標籤的空位，分別是「該O下了」、「誰贏了」、「該X下了」 lab1.setBackground(Color.gray); lab1.setFont(new Font(&quot;Serief&quot;,Font.BOLD,18)); lab2.setBackground(Color.gray); lab2.setFont(new Font(&quot;Serief&quot;,Font.BOLD,18)); lab3.setBackground(Color.gray); lab3.setFont(new Font(&quot;Serief&quot;,Font.BOLD,18)); frm.add(lab1); frm.add(lab2); frm.add(lab3); lab2.setVisible(false); lab3.setVisible(false); // 按鈕 for(int i = 0; i &amp;lt; 9; i++){ frm.add(new Button(Integer.toString(i)), i + 3); } frm.setVisible(true); }}即會產生以下結果：順利預留空間且按鈕正確排列問題2：Button 無法使用 setText()？在查資料的過程中發現，其實大家都用 JButton 而非 Button，這裡指的是 java.awt 中的 Button 喔。問題描述我想要實現「當按鈕被點擊時，按鈕中的文字顯示為 O」，所以將按鈕都加進 ActionListener(frm) 中，如下：for(int i = 0; i &amp;lt; 9; i++){ btn[i] = new Button(); btn[i].addActionListener(frm); frm.add(btn[i], i + 3); }我也新增了一個 function： public void actionPerformed(ActionEvent e){ Button actionBtn = (Button) e.getSource(); btn[1].setText(&quot;O&quot;); }他卻一直顯示這個問題：D:\\Java\\hw1 ❯ javac .\\hw1.java -encoding utf-8.\\hw1.java:52: error: cannot find symbol btn[1].setText(&quot;O&quot;); ^ symbol: method setText(String) location: class Button1 error為何如此？這世界上沒有一個叫做 setText()，且傳入了一個 String 當參數的 function。設定 Button 中的文字應用 setLabel()，而不是 setText()。不過確實還有其他 object 是用 setText()，這點需要多注意⚠ 修改成果按下按鈕後要觸發的 function 長這樣：public void actionPerformed(ActionEvent e){ Button actionBtn = (Button) e.getSource(); // 下棋！ ++turn; if(turn % 2 != 0){ lab1.setVisible(false); lab3.setVisible(true); actionBtn.setLabel(&quot;O&quot;); } else{ lab1.setVisible(true); lab3.setVisible(false); actionBtn.setLabel(&quot;X&quot;); } }最後的成果：可以正確顯示圈和叉成品經過一點波折，終於完成了小小的圈圈叉叉遊戲啦～這是我第一次用視窗來設計程式，能夠和這種 GUI 互動的感覺真的成就感爆棚！這裡是成果 demo: 終於像個圈圈叉叉了！這裡是完整的程式碼：import java.awt.*;import java.awt.event.*;public class hw1 extends Frame implements ActionListener{ static hw1 frm = new hw1(); static Label lab1 = new Label(&quot;It&#39;s \\&quot;O\\&quot; turn.&quot;); static Label lab2 = new Label(); //win static Label lab3 = new Label(&quot;It&#39;s \\&quot;X\\&quot; turn.&quot;); // X static int turn = 0; // turn % 2 == 0 -&amp;gt; O, turn % 2 == 1 -&amp;gt; X static Button[] btn = new Button[9]; public static void main(String args[]){ // 設定版面 GridLayout grid = new GridLayout(4, 3); frm.setLayout(grid); frm.setTitle(&quot;Tic-Tac-Toe&quot;); frm.setSize(600, 800); frm.setBackground(Color.white); frm.setLocation(200, 50); // 設定標籤屬性 lab1.setBackground(Color.gray); lab1.setFont(new Font(&quot;Serief&quot;,Font.BOLD,18)); lab2.setBackground(Color.gray); lab2.setFont(new Font(&quot;Serief&quot;,Font.BOLD,18)); lab3.setBackground(Color.gray); lab3.setFont(new Font(&quot;Serief&quot;,Font.BOLD,18)); frm.add(lab1); frm.add(lab2); frm.add(lab3); lab2.setVisible(false); lab3.setVisible(false); // 按鈕 for(int i = 0; i &amp;lt; 9; i++){ btn[i] = new Button(); btn[i].addActionListener(frm); frm.add(btn[i], i + 3); } frm.setVisible(true); // 關閉視窗鍵被點下就結束程式 frm.addWindowListener(new WindowAdapter(){ public void windowClosing(WindowEvent e){System.exit(0);} }); } public void actionPerformed(ActionEvent e){ Button actionBtn = (Button) e.getSource(); // 下棋！ ++turn; if(turn % 2 != 0){ lab1.setVisible(false); lab3.setVisible(true); actionBtn.setLabel(&quot;O&quot;); } else{ lab1.setVisible(true); lab3.setVisible(false); actionBtn.setLabel(&quot;X&quot;); } // 判斷輸贏 String[] game = new String[9]; for(int i = 0; i &amp;lt; 9; ++i){ game[i] = btn[i].getLabel(); } boolean win = false; for(int i = 0; i &amp;lt; 3; ++i){ // 橫列 if(game[i * 3] == game[i * 3 + 1] &amp;amp;&amp;amp; game[i * 3] == game[i * 3 + 2] &amp;amp;&amp;amp; game[i * 3] != &quot;&quot;){ win = true; break; } // 直行 if(game[i] == game[i + 3] &amp;amp;&amp;amp; game[i] == game[i + 6] &amp;amp;&amp;amp; game[i] != &quot;&quot;){ win = true; break; } } // 斜線 if(game[0] == game[4] &amp;amp;&amp;amp; game[0] == game[8] &amp;amp;&amp;amp; game[0] != &quot;&quot;) win = true; if(game[2] == game[4] &amp;amp;&amp;amp; game[2] == game[6] &amp;amp;&amp;amp; game[2] != &quot;&quot;) win = true; // 輸出勝利訊息 if(win == true){ if(turn % 2 != 0){ lab3.setVisible(false); lab2.setText(&quot;\\&quot;O\\&quot; win!&quot;); lab2.setVisible(true); } else{ lab1.setVisible(false); lab2.setText(&quot;\\&quot;X\\&quot; win!&quot;); lab2.setVisible(true); } } else if(turn == 9){ lab1.setVisible(false); lab3.setVisible(false); lab2.setText(&quot;Draw!&quot;); lab2.setVisible(true); } }}" }, { "title": "電影心得：Coded Bias 編碼偏見", "url": "/posts/movie_coded_bias/", "categories": "日常碎碎唸", "tags": "movie, AI, thoughts", "date": "2022-04-22 05:05:00 +0800", "snippet": "在開始之前，我想問一個情境題： 你是一間科技公司的 CEO，現在要從上百份履歷中挑出一些好的，你希望能公平並有效的挑出適合的人選。你會選擇： 本公司工程師們的結晶：酷酷 AI 聘請的專業人士：資深 HR 請把答案留在心裡，後面會提到我的看法。電影介紹這次要分享的是一部紀錄片：Coded Bias, 編碼偏見。 我覺得他的翻譯更適合叫做「偏見編碼」，不過 code 不論翻成編碼還是編程我都覺得怪怪的就是了。這是他的預告片（trailer 的中文是這個嗎？），可以打開 cc 字幕協助觀看: 簡單來說，一名正就讀 MIT 的黑人女性偶然發現她的 AI 無法識別她的臉，直到她戴上了一副白色面具，功能才正常運作。她想，是不是燈光不對、角度不對抑或是眼睛沒看著鏡頭呢？答案是：都不是，她所使用的 AI Model 本身就難以辨識黑人。我過去的想法不論是因為我從小就是一個對科技抱有憧憬的孩子，還是那些販賣、製作 AI 的企業的宣傳，我以前認為 AI 是絕對理性的。也因此他可以說是公平、公正、不戴有色眼鏡看人的代名詞。但，怎麼說呢，人類社會是一個很不公平的地方，為什麼從人類手中製造的「人工智慧」會是「公平、公正」的呢？我不曾想過這個問題。電影中的想法AI 藉由機器學習來探索這個世界，人們在網路上的發言、人類過去的歷史本就不是完全公平的，加上製造 AI 的人會有意無意的控管 AI 的資訊來源，AI 就像是工程師的孩子一樣。這些導致 AI 打從一開始就接收了帶有偏見的資訊，所以他們也用有偏見的演算法去評判一個人。電影中的例子無處不在的 AI 正主導著人的去向在幾年前，美國的街上都有配置人臉辨識系統，此系統會評判路過的人是否是通緝犯。有人不願被收集個人資料而拉起衣領蒙面，卻被警察攔下，因為他試圖掩蓋身分。這套系統中，很多人被誤判成罪犯，其中不乏小孩子，這讓人開始懷疑 AI 的合理性。還有一個例子是關於一名黑人女性，她曾入獄服刑，出獄後有了工作，並且獲得了幾次最佳市民獎，卻因為她是「黑人」、「女性」而被系統評判為高犯罪風險族群，因此她必須每周回去匯報生活情形。她當然有跟相關單位反應過，然而那個單位回覆她，他們必須依照系統行事。這就像是十年前的一個經典討論議題：AI 可以當法官嗎？若答案是否，那我們怎能使用 AI 來評斷一個人是否需要被搜查或是犯罪的機率呢？大公司的 AI Model 就出了問題片中提到，Amazon 曾販賣對性別、種族不友善的 AI，即使主角向其提出了研究結果，他們仍不認為自己的產品有錯，反而來指責主角不夠專業。Amazon 是販賣 AI 的源頭，這種出了問題的 AI 流入市面，就會造成上述的問題。或許你的想法跟我一樣：他們可是 Amazon 欸！這麼大的公司怎麼可能不尊重他人呢？Well, 他們是資本家，對他們來說「利益」才是第一優先，若產品出了問題，哪來的利潤呢？不過其中也有好的例子，IBM 也被發現了有這類問題，當他們在判斷各人種時的準確度，竟是天差地遠。當白人的準確度是95%以上時，黑人女性竟只有約60%。令人讚賞的是， IBM 在接獲提醒後就馬上更改，讓所有人種、性別的準確度都來到了98%以上。AI 反而造成了社會的退步當使用了有偏見的 AI 來決定我們的下一步，人類可能朝向更加歧視與不平等的生活前進。而透過耳熟能詳的演算法所推播的訊息也限制了我們的資訊攝取，你想，當你今天被推送了很多民進黨的壞話，你還會想投給他嗎？ 我覺得很酷的一點是，科技在讓我們退步欸。街上人臉辨識的取消在影片的最後，美國各州相繼取消在街上設置人臉辨識系統。雖然仍舊沒有制定演算法的相關法律，但這也算是一種進步吧。不過科技與人權依舊在拉扯中。我的看法在看一半的時候，我和我朋友馬上打開了 IG 查看他們的隱私權政策。IG 可以取用我們的照片與其它個人資訊來協助他們推送給我們更適合的功能與文章。先不論隱私相關的東西，IG 可以不要再推給我一些瞎妹語錄和星座語錄了嗎！！所以，不要讓 AI 控制了你的思想，也小心身邊可能會侵犯隱私的小細節。最後，推薦各位去找個朋友一起看這部片，一起罵公司和政府。" }, { "title": "嗨你好，我是 Tita", "url": "/posts/intro/", "categories": "日常碎碎唸", "tags": "about-me, dairy", "date": "2022-04-20 21:58:00 +0800", "snippet": "我從哪來你好啊，我是 Tita，在2022年4月從 Medium 轉來自己寫 github page 的資工仔。我怎麼會在這去年夏天（2021年）的我正就讀非四大四中的資工系（現在也是啦哈），一個不小心當上 GDSC Lead，接觸到一些社群大佬。他們說經營一個自己的 blog 是很讚的事，所以我就前往了 Medium 開啟了自己的寫作之路。然而，Medium 雖然好看，卻總覺得它的介面有很多與文章不相干的功能，而且除了背景顏色和字型（中文字型幾乎不可動）之外，都沒辦法自訂。所以就想說用 jekyll 自己架一個，往後有任何想要更動的，都會相對簡單。而且能用 markdown 來寫文章會更加的自由而且熟悉。這個 blog 會做些什麼 簡單來說就是，everything。我會將所有我覺得值得紀錄的東西寫在這裡，小至日常見到的梗圖，大到一些教學或是 Project demo。反正我會將所有文章進行分類，希望將來回頭看的時候會讓我回想起這段時光，或是溫故知新。小提示，左下角可以變換明亮/黑暗主題，我原本想要鎖定成黑暗，但黑暗不知道為什麼看起來不太順眼，之後我調一調再看要不要切換過去吧。結語在新平台上請多多指教，之後還不確定會不會繼續更新 Medium 上的文章，希望大家和我（？）都能在這裡玩得愉快。" } ]
